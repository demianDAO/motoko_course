# Motoko 基本语法

## 为什么学习语法

语法是为了让语言更严谨!

语法是指形式的代码，并与语义学结合出机器读懂的语言.

## 一版开发语言的语法的类型

不论是 C 还是 Java，Python 或者 Ruby，都有自己的语法树，这些语法树几乎是一样的，都是基于栈机器的语法。以深受广大编程爱好者喜欢的 Python 为例，当你引入 Python 自带的库 dis 以后，就可以看到你写的 Python 程序，编译成的语法树是个什么状态，还有 Python 语言自带的 ast 库，直接把语法树给你打印在屏幕上。其它的语言也都有类似的功能，什么先词法分析后语法分析，这就牵扯到《编译原理》.

### BNF 和 EBNF

BNF(Backus-Naur Form)是描述编程语言的文法。巴科斯范式是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言。

自然语言存在不同程度的二义性。这种模糊、不确定的方式无法精确定义一门程序设计语言。必须设计一种准确无误地描述程序设计语言的语法结构，这种严谨、简洁、易读的形式规则描述的语言结构模型称为文法。

ABBF

RFC2234 定义了扩展的巴科斯范式(ABNF)。近年来在 Internet 的定义中 ABNF 被广泛使用。扩充巴科斯-诺尔范式(ABNF)基于了巴科斯-诺尔范式(BNF)，但由它自己的语法和推导规则构成。这种元语言的发起原则是描述作为通信协议(双向规范)的语言的形式系统。

太多了,具体去阅读原文吧!!!

[使用巴科斯範式(BNF/EBNF)定義語言](https://hackmd.io/@ShenTengTu/HJzCM3aDr?type=view)

[BNF 范式](https://sighingnow.github.io/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/bnf.html)

## motoko 的数据类型

作为合约语言 Motoko 对类型非常严格,也是为了防止在编码中出现低级错误漏洞.

Motoko 程序中的每个变量都带有一个关联的类型，并且该类型在程序执行之前是静态已知的。编译器会检查每个变量的每次使用以防止运行时类型错误，包括空引用错误、无效字段访问等。

一般来说，我们可以将类型分为两类：原始类型和复合类型

原始类型是整数、自然数、浮点数、字符、文本和布尔值。

例如: `let a : Nat = 10;`

复合类型可以是元组、数组、对象、变体、函数、异步值或错误值。

例如: `let b : [Nat] = [1, 2, 3, 4, 5] ;`

### 1. 整数-Int

类型 Int 是带符号整数。支持算数运算符操作和比较运算符操作。Int 支持任意精度。整数可以分配正数或负数。

Nat 是 Int 的子类型，每个 Nat 类型的表达式也是 Int 类型的表达式，每个 Nat 类型的值也是一个 Int 类型的值。

Int8/Int16/Int32/Int64
Int8、Int16、Int32 和 Int64 类型分别表示具有 8、16、32 和 64 位精度的带符号整数。支持算数运算符操作和比较运算符操作以及位运算符操作。

在进行算数操作或位操作，可能会因为精度问题产生陷阱。

这些类型之间或者和其他数值类型之间都不存在子类型的关系。

有一些方法可以声明一个整数变量：

```
let a : Int = 1;
let b : Int = -10;
let c : Int = 1_000_000;
let d : Int = 0xf4; // 245
```

`public query func add(a : Int, b : Int) : async Int { return a+b; };`

### 2.自然数-Nat

类型 Nat 是自然数。支持算数运算符操作和比较运算符操作。Nat 支持任意精度，当 Nat 使用减法时可能会产生下溢陷阱。

Nat 是 Int 的子类型，每个 Nat 类型的表达式也是 Int 类型的表达式，每个 Nat 类型的值也是一个 Int 类型的值。

#### Nat8/Nat16/Nat32/Nat64

Nat8、Nat16、Nat32 和 Nat64 类型分别表示具有 8、16、32 和 64 位精度的自然数。支持算数运算符操作和比较运算符操作以及位运算符操作。

在进行算数操作或位操作，可能会因为精度问题产生陷阱, 并且如果您尝试分配负数，Motoko 程序将陷入陷阱。

这些类型之间或者和其他数值类型之间都不存在子类型的关系。

```
let a : Nat = 1;
let b : Nat = 1_000_000;
let c : Nat = 0xf4; //245
```

**提示: motoko 中的整数默认为 Nat 类型。**

### 3. Bool

类型 Bool 具有值 true 和 false，支持 if 表达式、while 表达式、not 表达式、and 表达式、or 表达式等。

`let A = Bool`

### 4.Char

Char 将字符表示为 Unicode 字符集中的代码点。支持比较运算符操作。使用 Char.toText()可以将字符转换为长度为 1 的文本。

字符可以转换为 Nat32，而 0 .. 0x1FFFFF 范围内的 Nat32 可以转换为 Char，超过此范围的 Nat32 转换时会产生陷阱。

### 5.Text

Text 类型表示 Unicode 字符序列（即字符串）。方法 t.size()返回文本 t 中的字符数。支持拼接运算符操作和比较运算符操作。

可以通过 t.chars() 对字符串进行顺序迭代，例如 for (c : Char in t.chars()) { ... c ... }。

### 6.Blob

Blob 类型表示二进制 Blob 或字节序列。方法 t.size()返回文本 t 中的字节数。支持比较运算符操作。

可以通过 t.vals() 对 Vlob 进行顺序迭代，例如 for (v : Nat8 in b.vals()) { ... v ... }。

### 7.Float

Float 类型表示的 64 位浮点值。支持算数运算符操作和比较运算符操作。

### 8.Principal

类型 Principal 表示不透明的身份主体，例如 canister 和用户。它们可用于识别共享函数的调用者并用于简单的身份验证。支持比较运算符操作。

尽管不透明，但身份主体可以转换为二进制 Blob 值，以实现更高效的散列和其他应用程序。

### 9.Error

Error 类型用于表示一个错误，错误只能在异步上下文中抛出和捕获，通常是 share 函数或 async 表达式的主体。

Error 暴漏了以下函数：

      E.reject : Text → Error：创建一个新的Error，该Error的code为#canister_reject。
      E.code : Error → E.ErrorCode：获取指定Error的code。
      E.message : Error → Text。获取指定Error的文本信息。

注意：#canister_reject 以外的代码错误（即系统错误）可能会被捕获并抛出，但这不是用户构建的。

## 推荐播客

[6.定义编程语言语法的语言 | 忽软忽硬](https://liuyandong.com/archives/podcast/hardorsoft06)

//下节我们讲复合类型
